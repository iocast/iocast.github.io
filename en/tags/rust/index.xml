<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>rust on think twice code once!</title><link>https://iocast.github.io/en/tags/rust/</link><description>Recent content in rust on think twice code once!</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>All rights reserved Â© 2019</copyright><lastBuildDate>Sat, 26 Oct 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://iocast.github.io/en/tags/rust/index.xml" rel="self" type="application/rss+xml"/><item><title>Rust OOP?!...</title><link>https://iocast.github.io/en/post/coding/rust/rust-call-expressions/</link><pubDate>Sat, 26 Oct 2019 00:00:00 +0000</pubDate><guid>https://iocast.github.io/en/post/coding/rust/rust-call-expressions/</guid><description>Wer kennt das nicht. Man lernt gerade eine neue Programmiersprache und mÃ¶chte alt bewÃ¤rtes anwenden. Hmmm ðŸ˜• ðŸ˜  ðŸ˜¡ &amp;hellip; nur wie? Diesesmal versuche ich einige OOP Konzepte in Rust umzusetzen.
Mehrdeutiger Funktionsaufruf (&amp;ldquo;Funktionen Ã¼berladen&amp;rdquo;) traitPretty{fn print(&amp;amp;self);}traitUgly{fn print(&amp;amp;self);}struct Foo;implPrettyforFoo{fn print(&amp;amp;self){}}struct Bar;implPrettyforBar{fn print(&amp;amp;self){}}implUglyforBar{fn print(&amp;amp;self){}}fn main(){letf=Foo;letb=Bar;// we can do this because we only have one item called `print` for `Foo`s f.print();// more explicit, and, in the case of `Foo`, not necessary Foo::print(&amp;amp;f);// if you&amp;#39;re not into the whole brevity thing &amp;lt;FooasPretty&amp;gt;::print(&amp;amp;f);// b.</description></item></channel></rss>